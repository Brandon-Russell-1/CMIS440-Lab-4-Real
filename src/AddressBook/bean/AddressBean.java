package AddressBook.bean;

/**
* Program Name: CMIS440 Lab 4 Address Book Web App
* @author Brandon R Russell
* @Course CMIS440
* Date: Jan 6, 2011
* IDE: MyEclipse 9.0 M1
* OS: Windows 7 64 bit
* Java: JDK 1.6.0_13, Java EE 5, JSF 1.2, JPA 1.0 w/ Derby and EclipseLink, 
*		IceFaces 1.8.1, GlassFish 2.1.1 & GlassFish v3 Prelude
* Tested on Firefox 3.6.13 w/ 22in, 17in, and 14in monitors w/ 1680x1050, 1440x900, 
* 													and 1280x1024 resolution settings.
* Files: AddressBean.java, Logger.java, SortableList.java, Addresses.java, 
* 		 AddressesDAO.java, EntityManagerHelper.java, persistence.xml, faces-config.xml,
*        web.xml, AddressBook.jspx, AddressBookCSS.css, index.html, ErrorPage.jspx,
*        ErrorPageCSS.css, ErrorRedirect.jsp
*
* Program Requirements: 
*Minimum Assignment Requirements. Extend the example web application in Chapter 30 as follows:
*Add fields for Email Address and Phone Number to the Addresses Table in the AddressBook 
*	database.
*Add labels and text fields, with appropriate validators, to all presentation forms for the 
*	Email Address and Phone Number fields.
*Implement a delete record functionality. The basic approach is to have the user search
* 	for a record and then be given the option to delete this record.
*Implement an update record functionality. The basic approach is to have the user search
* 	for a record and then be allowed to make changes and save these changes back to the 
* 	database.
* Assignment Optional Implementations: 
*Incorporate trace logging into the Java code classes. These trace logs are invaluable in
* 	tracking down customer reported issues. When writing to your log file, ask yourself:
*   'What will I need to know if a customer reports an issue and all I have is my trace 
*   log to analysis and resolve the issue'. To implement your trace logging, create a class
*   called Logger that takes a file name and optional path in its constructor and provides
*   one or more log methods. The default file name will be AddressBook.log and the default
*   file path will be the current working directory. Possible log methods might be: 
*log(String msg) - log the given message to the provided Path/File Name. 
*log(String msg, int value) - log the given message and value to the provided Path/File Name 
*	in a format: message = value 
*
* Program Design: The basic program design is that once the program is loaded the user 
* can enter into one form a new address to be entered into the database. In the next 
* form the user has the option to do a search by last name, which utilizes autocomplete,
* and displays the results in the datatable. Finally, the datatable/form allows the 
* user to view and also edit/delete records. I went with a MVC design: the 
* AddressBook.bean package is my Controller, the myPersistence package is my Model,
* and the WebRoot files are my View.
*
* Things you what me to know before I grade your work: Using MyEclipse, most of the 
* persistence files in myPersistence package were auto-generated by the IDE; however,
* even still I did go through each file making specific changes I needed plus adding
* my own comments and styling throughout. The projects appears to work well on both
* Glassfish 2.1.1 and v3 Prelude, but I think for some reason it works best on 
* Glassfish 2.1.1. Also, I definitely went beyond the 80 character mark in a lot of
* these files, but for some areas here and especially in the front-end code it was 
* just more feasible to go beyond 80 characters.
*/

/** This class manages interaction between front-end and back-end classes.
* Basically, this class is considered a Controller, almost like a buffer 
* between all dealings between the front-end website and the back-end database. 
*|----------------------------------------------------------------------------|
*|                           CRC: AddressBean                                 |
*|----------------------------------------------------------------------------|
*|Used to interact with back-end                           AddressBook.jspx   |
*|Used to interact with front-end                          EntityManagerHelper|
*|                                                         AddressesDAO       |
*|Object model for table entries                           Addresses          |
*|Used to keep log of user actions                         Logger             |
*|Extended to provide sorting for front-end table          SortableList       |
*|----------------------------------------------------------------------------|
*
* @TheCs Cohesion - All methods in this class work together on similar task.
* Completeness - Completely interacts with front-end and back-end classes.
* Convenience - There are sufficient methods and variables to complete the
*                required task.
* Clarity - The methods and variables are distinguishable and work in a
*           uniform manner to provide clarity to other programmers.
* Consistency - All names,parameters ,return values , and behaviors follow
*               the same basic rules.
*/



import java.util.*;

import javax.faces.model.SelectItem;
import javax.faces.application.Application;
import javax.faces.application.FacesMessage;
import javax.faces.application.ViewHandler;
import javax.faces.component.UIComponent;
import javax.faces.component.UIInput;
import javax.faces.component.UIViewRoot;
import javax.faces.context.FacesContext;
import javax.faces.event.ValueChangeEvent;
import myPersistence.Addresses;
import myPersistence.AddressesDAO;
import myPersistence.EntityManagerHelper;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


public class AddressBean extends SortableList{

	
	private AddressesDAO myAddressesDAO = new AddressesDAO();
	private Addresses myTableAddress = new Addresses();
	private Addresses myNewAddress = new Addresses();
	private Addresses mySearchAddress = new Addresses();
	private List<Addresses> myAddresses = new ArrayList<Addresses>();
	private List<SelectItem> lastNames;//Used for auto-complete in search field
	private Logger myLog = new Logger();
	private boolean instructionsVisible = false;
	private String notifyMessage = ""; //Send messages to front-end
	private Long tempEditAddressId; //Holds ID of Address object being edited.

    

	
    /** Constructor initializes an AddressBean object.
     *@TheCs Cohesion - Initializes an AddressBean object.
	 * Completeness - Completely initializes an AddressBean object.
	 * Convenience - Simply initializes an AddressBean object.
	 * Clarity - It is simple to understand that this initializes an
     *           AddressBean object.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.             
	 */	
	public AddressBean() {
		/**
		 * First a call is made to the extended SortableList class to set the 
		 * current sorted column to the 'ID' field. MyAddressesDAO finalAll method
		 * is called to fill the myAddresses list for the front-end datatable.
		 */
		super("ID");
	}
	
	
    /** Retrieves the current address object used by the table.
     *@TheCs Cohesion - Retrieves the current address object used by the table.
	 * Completeness - Completely retrieves the current address object used by 
	 * 				  the table.
	 * Convenience - Simply retrieves the current address object used by the table.
	 * Clarity - It is simple to understand that this retrieves the current 
	 *           address object used by the table.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
	 * @return myTableAddress object               
	 * @throws Exception if myTableAddress is null
	 * @exception Exception general exception capture 
	 */		
	public Addresses getCurrentTableAddress(){
		try{
			if (myTableAddress == null){
				throw new Exception(
						"The Table Address object is null on getCurrentTableAddress!");
			}			
			return myTableAddress;
		}catch (Exception exception){
			myLog.log(exception.getMessage());
			notifyMessage = exception.getMessage();
			return null;
		}					
		
	}

    /** Sets the current address object used by the table.
     *@TheCs Cohesion - Sets the current address object used by the table.
	 * Completeness - Completely sets the current address object used by 
	 * 				  the table.
	 * Convenience - Simply sets the current address object used by the table.
	 * Clarity - It is simple to understand that this sets the current 
	 *           address object used by the table.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
	 * @param tableAddress sets the table address object to another address object
	 * @throws Exception if tableAddress is null
	 * @exception Exception general exception capture               
	 */			
	public void setCurrentTableAddress(Addresses tableAddress){
		try{
			if (tableAddress == null){
				throw new Exception(
						"The Table Address object is null on setCurrentTableAddress!");
			}			
			myTableAddress = tableAddress;
		}catch (Exception exception){
			myLog.log(exception.getMessage());
			notifyMessage = exception.getMessage();
		}		
	}
		
    /** Retrieves the current address object used to add a record.
     *@TheCs Cohesion - Retrieves the current address object used to add a record.
	 * Completeness - Completely retrieves the current address object used to 
	 *                add a record.
	 * Convenience - Simply retrieves the current address object used to add a 
	 *               record.
	 * Clarity - It is simple to understand that this retrieves the current 
	 *           address object to add a record.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
	 * @return myNewAddress object  
	 * @throws Exception if myNewAddress is null
	 * @exception Exception general exception capture             
	 */			
	public Addresses getCurrentNewAddress(){
		try{
			if (myNewAddress == null){
				throw new Exception(
						"The New Address object is null on getCurrentNewAddress!");
			}
			return myNewAddress;
		}catch (Exception exception){
			myLog.log(exception.getMessage());
			notifyMessage = exception.getMessage();
			return null;
		}
	}

    /** Sets the current address object used to add a record.
     *@TheCs Cohesion - Sets the current address object used to add a record.
	 * Completeness - Completely sets the current address object used to add
	 *                a record.
	 * Convenience - Simply sets the current address object used to add a record.
	 * Clarity - It is simple to understand that this sets the current 
	 *           address object used to add a record.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
	 * @param newAddress sets the new address object to another address object     
	 * @throws Exception if newAddress is null
	 * @exception Exception general exception capture           
	 */	
	public void setCurrentNewAddress(Addresses newAddress){
		try{
			if (newAddress == null){
				throw new Exception(
						"The New Address object is null on setCurrentNewAddress!");
			}				
			myNewAddress = newAddress;
		}catch (Exception exception){
			myLog.log(exception.getMessage());
			notifyMessage = exception.getMessage();
		}		
	}	

    /** Retrieves the current address object used to search for a record.
     *@TheCs Cohesion - Retrieves the current address object used to 
     *                  search for a record.
	 * Completeness - Completely retrieves the current address object used to 
	 *                search for a record.
	 * Convenience - Simply retrieves the current address object used to search
	 *               for a record.
	 * Clarity - It is simple to understand that this retrieves the current 
	 *           address object to search for a record.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
	 * @return mySearchAddress object 
	 * @throws Exception if mySearchAddress is null
	 * @exception Exception general exception capture               
	 */		
	public Addresses getCurrentSearchAddress(){
		try{
			if (mySearchAddress == null){
				throw new Exception(
						"The Search Address object is null on getCurrentSearchAddress!");
			}			
			return mySearchAddress;
		}catch (Exception exception){
			myLog.log(exception.getMessage());
			notifyMessage = exception.getMessage();
			return null;
		}			
	}
	
    /** Sets the current address object used to search for a record.
     *@TheCs Cohesion - Sets the current address object used to search for a 
     *                  record.
	 * Completeness - Completely sets the current address object used to search
	 *                for a record.
	 * Convenience - Simply sets the current address object used to search for
	 *               a record.
	 * Clarity - It is simple to understand that this sets the current 
	 *           address object used to search for a record.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
	 * @param searchAddress sets the search address object to another address object    
	 * @throws Exception if searchAddress is null
	 * @exception Exception general exception capture           
	 */		
	public void setCurrentSearchAddress(Addresses searchAddress){
		try{
			if (searchAddress == null){
				throw new Exception(
						"The Search Address object is null on setCurrentSearchAddress!");
			}					
			mySearchAddress = searchAddress;
		}catch (Exception exception){
			myLog.log(exception.getMessage());
			notifyMessage = exception.getMessage();
		}					
	}	

    /** Retrieves the address DAO object.
     *@TheCs Cohesion - Retrieves the address DAO object.
	 * Completeness - Completely retrieves the address DAO object.
	 * Convenience - Simply retrieves the address DAO object.
	 * Clarity - It is simple to understand that this retrieves the 
	 *           address DAO object.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
	 * @return myAddressesDAO object 
	 * @throws Exception if myAddressesDAO is null
	 * @exception Exception general exception capture               
	 */		
	public AddressesDAO getAddressDao(){
		try{
			if (myAddressesDAO == null){
				throw new Exception(
						"The Address DAO object is null on getAddressDao!");
			}			
			return myAddressesDAO;
		}catch (Exception exception){
			myLog.log(exception.getMessage());
			notifyMessage = exception.getMessage();
			return null;
		}			
	}	
	
    /** Sets the address DAO object.
     *@TheCs Cohesion - Sets the address DAO object.
	 * Completeness - Completely sets the address DAO object.
	 * Convenience - Simply sets the address DAO object.
	 * Clarity - It is simple to understand that this sets the address
	 * 	 	     DAO object.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
	 * @param addressesDAO set the address DAO object.   
	 * @throws Exception if addressesDAO is null
	 * @exception Exception general exception capture            
	 */			
    public void setAddressDao(AddressesDAO addressesDAO) {
    	try{
			if (addressesDAO == null){
				throw new Exception(
						"The AddressesDAO object is null on setAddressDao!");
			}    		
    		myAddressesDAO = addressesDAO;
		}catch (Exception exception){
			myLog.log(exception.getMessage());
			notifyMessage = exception.getMessage();
		}	    		
    }
	 
	
    /** Adds a new address record to the database.
     *@TheCs Cohesion - Adds a new address record to the database.
	 * Completeness - Completely adds a new address record to the database.
	 * Convenience - Simply adds a new address record to the database.
	 * Clarity - It is simple to understand that this adds a new address record
	 *           to the database.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
	 * @throws Exception if myNewAddress object is null               
	 * @exception Exception general exception capture      
	 * @return success or failure depending on if transaction goes through        
	 */			    
	public String addAddress(){
		try{
			FacesContext context = FacesContext.getCurrentInstance();
			if (myNewAddress == null){
				throw new Exception("New Address object is null on addAddress");
			}else if (context.getMessages().hasNext()){
				/**
				 * Here, if there are any error messages, let the user know
				 * they need to clear these messages before adding a new record.
				 */
				FacesMessage msg = 
					new FacesMessage("Clear all errors before adding record!");
				context.addMessage("addForm:Add", msg);
				return "failure";
			}
			/**
			 * First the EntityManagerHelper is called to initiate the transaction.
			 * Then, the AddressesDAO object save method is called to persist the
			 * new address object to the database and the EntityManagerHelper
			 * is called again to commit the changes.
			 */
			EntityManagerHelper.beginTransaction();
			myAddressesDAO.save(myNewAddress);
			EntityManagerHelper.commit();
			/**
			 * myLog is called to write to a file that the add was successful and
			 * then the clear method is called to clear out all the objects and
			 * renew the list.
			 */
			myLog.log("ID: " + myNewAddress.getAddressid() 
					+ " Successfully added into database");
			clear();
			notifyMessage = "Record Added!";
			return "success";
			}catch (Exception exception){
				myLog.log(exception.getMessage());
				notifyMessage = exception.getMessage();
				return "failure";
			}
	}

    /** Updates a address record in the database.
     *@TheCs Cohesion - Updates a address record in the database.
	 * Completeness - Completely updates a address record in the database.
	 * Convenience - Simply updates a address record in the database.
	 * Clarity - It is simple to understand that this updates a address record
	 *           in the database.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
	 * @throws Exception if myTableAddress object is null         
	 * @exception Exception general exception capture              
	 * @return success or failure depending on if transaction goes through
	 */		
	public String updateAddress(){
		try{
			FacesContext context = FacesContext.getCurrentInstance();
			if (myTableAddress == null){
				throw new Exception("MyTableAddress object is null on updateAddress");
			}else if (context.getMessages().hasNext()){
				/**
				 * Here, if there are any error messages, let the user know
				 * they need to clear these messages before updating a new record.
				 */
				 FacesMessage msg = 
					 new FacesMessage("Clear all errors before saving record!");
				 context.addMessage("editForm:Save", msg);	
				 
				return "failure";
			}
					
			/**
			 * First the EntityManagerHelper is called to initiate the transaction.
			 * Then, the AddressesDAO object update method is called to merge the
			 * changed address object to the database and the EntityManagerHelper
			 * is called again to commit the changes.
			 */			
			EntityManagerHelper.beginTransaction();
			myAddressesDAO.update(myTableAddress);
			EntityManagerHelper.commit();
			/**
			 * myLog is called to write to a file that the update was successful and
			 * then the cancelEdit method is called to clear out all table
			 * address objects and also sets the editable property to false to
			 * indicate that the table should not have any editable fields.
			 */			
			myLog.log("ID: " + myTableAddress.getAddressid() 
					+ " Successfully updated in database");
			notifyMessage = "Record Updated!";
			cancelEdit();
			return "success";
		}catch (Exception exception){
			myLog.log(exception.getMessage());
			notifyMessage = exception.getMessage();
			return "failure";
		}		
	}
	
    /** Deletes a address record from the database.
     *@TheCs Cohesion - Deletes a address record from the database.
	 * Completeness - Completely deletes a address record from the database.
	 * Convenience - Simply deletes a address record from the database.
	 * Clarity - It is simple to understand that this deletes a address record
	 *           from the database.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.   
	 * @throws Exception if myTableAddress is null           
	 * @exception Exception general exception capture              
	 * @return success or failure depending on if transaction goes through
	 */		
	public String deleteAddress(){
		try{
			if (myTableAddress == null){
				throw new Exception("myTableAddress object is null on deleteAddress");
			}else if (myTableAddress.getAddressid().toString().length() == 0){
				
				/**
				 * Here, if the addressid field is blank then it creates a 
				 * new message to be displayed on the front-end and returns instead
				 * of attempting to delete a record since this is required to  
				 * delete the record.
				 */				
				
				 FacesContext context = FacesContext.getCurrentInstance();
				 FacesMessage msg = 
					 new FacesMessage("The record appears to not be selected for deletion.");
				 context.addMessage("editForm:Delete", msg);				
				return "failure";
			}
			/**
			 * First the EntityManagerHelper is called to initiate the transaction.
			 * Then, the AddressesDAO object delete method is called to remove the
			 * address object from the database and the EntityManagerHelper
			 * is called again to commit the changes.
			 */				
			EntityManagerHelper.beginTransaction();
			myAddressesDAO.delete(myTableAddress);
			EntityManagerHelper.commit();
			/**
			 * myLog is called to write to a file that the delete was successful and
			 * then the cancelEdit method is called to clear out all table
			 * address objects and also sets the editable property to false to
			 * indicate that the table should not have any editable fields.
			 */
			myLog.log("ID: " + myTableAddress.getAddressid() 
					+ " Successfully deleted from database");
			cancelEdit();
			notifyMessage = "Record Deleted!";
			return "success";
		}catch (Exception exception){
			myLog.log(exception.getMessage());
			notifyMessage = exception.getMessage();
			return "failure";
		}		
	}		
	
	
    /** Returns list of addresses objects for front-end table.
     *@TheCs Cohesion - Returns list of addresses objects for front-end table.
	 * Completeness - Completely returns list of addresses objects for front-end table.
	 * Convenience - Simply returns list of addresses objects for front-end table.
	 * Clarity - It is simple to understand that this returns list of addresses 
	 *           objects for front-end table.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
	 * @return myAddresses List 
	 * @throws Exception if mySearchAddress of myAddressesDAO are null                             
	 * @exception Exception general exception capture              
	 */		
	public List<Addresses> getAllAddresses(){
		try{
			if(mySearchAddress == null || myAddressesDAO == null){
				throw new Exception(
						"One or more objects required by the getAllAddresses are set to null!");
			}
			/**
			 * First, if mySearchAddress object doesn't have a last name set then 
			 * fill myAddresses List w/ all records and sort. Else use the .findByLastname
			 * method of the AddressesDAO object to populate the list with all records that
			 * match the last name entered.
			 */
			if ( mySearchAddress.getLastname() == null ||
					mySearchAddress.getLastname().equals("")){
				/**
				 * If the search field is blank get all the address objects and
				 * then sort before returning.
				 */
				myAddresses = myAddressesDAO.findAll();
				sort(); //Sort myAddresses
				notifyMessage = "Showing all records";
				return myAddresses;
				
			}else{
				/**
				 * Return records matching search criteria.
				 */
				myAddresses =  
					myAddressesDAO.findByLastname(mySearchAddress.getLastname());
				/**
				 * Below, if a field is being edited and a search is initiated
				 * during the edit, make sure the field being edited is in the
				 * new search results, otherwise cancel the edit.
				 */
				boolean tempEditCheckNotOnList = true;
				if (tempEditAddressId != null){
					for (Addresses tempAddress : myAddresses){
						if (tempAddress.getAddressid() == tempEditAddressId){
							/**
							 * If record is found, set to false and break out
							 * of loop since edited field is in search criteria
							 * it can remain editable.
							 */
							tempEditCheckNotOnList = false;
							break;
						}
					}					
				}
				if (tempEditCheckNotOnList){
					/**
					 * Cancel edit if not within new search criteria
					 */
					cancelEdit();
				}
				notifyMessage = "Showing records for specified last name";
				return myAddresses;
			}			
        }catch (Exception exception){
        	myLog.log(exception.getMessage());
        	notifyMessage = exception.getMessage();
        	return null;
        }
        
	}
	
    /** Provides auto-complete from database for search field.
     *@TheCs Cohesion - Provides auto-complete from database for search field.
	 * Completeness - Completely provides auto-complete from database for search field.
	 * Convenience - Simply provides auto-complete from database for search field.
	 * Clarity - It is simple to understand that this provides auto-complete from 
	 *           database for search field.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
	 * @param event a ValueChangeEvent linked to the search field on the front-end 
	 * @throws Exception if myAddressesDAO is null                                       
	 * @exception Exception general exception capture              
	 */		
	public void getAddressesByLastName(ValueChangeEvent event){
		/**
		 * Whenever the user types something into the search field on the
		 * front-end this method is called.
		 */
		try{
			if (myAddressesDAO == null){
				throw new Exception(
						"The myAddressesDAO object is null on getAddressesByLastName!");
			}
			/**
			 * This will take what the user typed into the searchWord object,
			 * makes a temp list of all addresses, makes a temp string list, and
			 * adds all last names to this list. 
			 */
			lastNames = new ArrayList<SelectItem>();
			List<Addresses> myTempAddresses = new ArrayList<Addresses>(myAddressesDAO.findAll());
			List<String> myTempLastNames = new ArrayList<String>();
			for (Addresses tempAddress : myTempAddresses){
				/**
				 * Add last names to list, make them all lower case so the hashset will remove
				 * ALL duplicates.
				 */
				myTempLastNames.add(tempAddress.getLastname().toLowerCase());
			}
			/**
			 * I use a HashSet here before reassigning back to the ArrayList because the HashSet
			 * will automatically remove any duplicate entries, in this case elements with the
			 * same last name. 
			 */
			HashSet<String> myTempHashSet = new HashSet<String>(myTempLastNames);
			/**
			 * Now that the HashSet has removed duplicate last names clear the temp
			 * last names array list and reassign to the elements of the HashSet.
			 */
			myTempLastNames.clear();
			myTempLastNames.addAll(myTempHashSet);
			/**
			 * Below, get the information inputed into the search field.
			 */
			Object searchWord = event.getNewValue();
			for(int i = 0; i < myTempLastNames.size(); i++){
				if (myTempLastNames.get(i).length() == 0){
					/**
					 * If for some reason the last name on this record is nothing
					 * then skip it.
					 */
					
				}else if (myTempLastNames.get(i).length() < 
						searchWord.toString().length()){
					/**
					 * If the length of the last name in this record is shorter 
					 * than the word being searched for, then it definitely won't
					 * match so skip it.
					 */
				
				}else if(myTempLastNames.get(i)
						.substring(0,searchWord.toString().length())
						.equalsIgnoreCase(searchWord.toString())){
					/**
					 * Finally, take a substring of the records last name to
					 * match the length of the word being searched for and then
					 * compare the two ignoring case and if equal add the name
					 * to the list.
					 */
					
					lastNames.add(
							new SelectItem(myTempLastNames.get(i),
										   myTempLastNames.get(i)));
				}
			}		
        }catch (Exception exception){
        	myLog.log(exception.getMessage());
        	notifyMessage = exception.getMessage();
        }		
		
	}
	
    /** Returns a list of last names for search field autocomplete.
     *@TheCs Cohesion - Returns a list of last names for search field autocomplete.
	 * Completeness - Completely Returns a list of last names for search field autocomplete.
	 * Convenience - Simply Returns a list of last names for search field autocomplete.
	 * Clarity - It is simple to understand that this Returns a list of last names 
	 *           for search field autocomplete.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @return lastNames a list of last names that match search field.   
     * @exception Exception general exception capture      
	 */		
	public List<SelectItem> getLastNameMatches(){
		try{
			return lastNames;
        }catch (Exception exception){
        	myLog.log(exception.getMessage());
        	notifyMessage = exception.getMessage();
        	return null;
        }			
	}
	
    /** Renews Addresses objects, refills myAddresses list, and undo's edit on table.
     *@TheCs Cohesion - Renews Addresses objects, refills myAddresses list, and undo's 
     *                  edit on table.
	 * Completeness - Completely renews Addresses objects, refills myAddresses list, 
	 *                and undo's edit on table.
	 * Convenience - Simply Renews Addresses objects, refills myAddresses list, and
	 *               undo's edit on table.
	 * Clarity - It is simple to understand that this Renews Addresses objects, 
	 *           refills myAddresses list, and undo's edit on table.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.  
     * @throws Exception if myAddressesDAO is null
     * @exception Exception general exception capture
     * @return success or failure depending on if clear is handled properly
	 */		
	public String clear(){
		try{
			myNewAddress = new Addresses();
			mySearchAddress = new Addresses();
			cancelEdit();
			/**
			 * The code below gets the current FacesContext and forces 
			 * the page to rerender, making sure a good 'Clear' is made.
			 */
			FacesContext context = FacesContext.getCurrentInstance();
			Application application = context.getApplication();
			ViewHandler viewHandler = application.getViewHandler();
			UIViewRoot viewRoot = viewHandler.createView(context, context
					.getViewRoot().getViewId());
			context.setViewRoot(viewRoot);
			context.renderResponse(); //Optional	
			notifyMessage = "";
			return "success";
        }catch (Exception exception){
        	myLog.log(exception.getMessage());
        	notifyMessage = exception.getMessage();
        	return "failure";
        }		    
		
	}

	
    /** Disables editable field on front-end table.
     *@TheCs Cohesion - Disables editable field on front-end table.
	 * Completeness - Completely disables editable field on front-end table.
	 * Convenience - Simply disables editable field on front-end table.
	 * Clarity - It is simple to understand that this disables editable field 
	 *           on front-end table.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @return success       
	 */		
	public String cancelEdit(){
		if(myTableAddress != null && tempEditAddressId != null){
			/**
			 * If not null then set the editable to false to clean up
			 * the UI.
			 */
			if (myAddresses.contains(myTableAddress)){
				/**
				 * First, check to see if the current myTableAddress object is in the myAddresses
				 * list and if so set it's editable to false.
				 */
				myAddresses.get(myAddresses.indexOf(myTableAddress)).setEditable(false);
			}else{
				/**
				 * Else, loop over all of the Address objects in the myAddresses
				 * list to find the object with the matching Address ID and set it's
				 * editable to false.
				 */
				for (Addresses tempAddress : myAddresses){
					if (tempAddress.getAddressid() == tempEditAddressId){
						/**
						 * Once found, set editable to false and break out
						 * of loop.
						 */
						tempAddress.setEditable(false);
						break;
					}
				}				
			}
			myTableAddress.setEditable(false);
			
		}
		tempEditAddressId = null;
		myTableAddress = new Addresses();
		return "success";
	}
	
    /** Makes a record on the front-end table editable.
     *@TheCs Cohesion - Makes a record on the front-end table editable.
	 * Completeness - Completely makes a record on the front-end table editable.
	 * Convenience - Simply makes a record on the front-end table editable.
	 * Clarity - It is simple to understand that this makes a record on 
	 *           the front-end table editable.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @throws Exception if myAddressesDAO is null
     * @exception Exception general exception capture         
     * @return success or failure depending on if transaction goes through
	 */		
	public String editAction() {
		try{
			if(myAddressesDAO == null){
				throw new Exception("myAddressesDAO is null on editAction!");
			}
			/**
			 * If another record is already being edited then return here and do nothing.
			 */
			if (myTableAddress.getAddressid() != null){
				notifyMessage = "You can only edit one record at a time";
				return "failure";
			}		
			if (tempEditAddressId != null){
				/**
				 * Set the myTableAddress object to the record that was clicked to be edited
				 * by using the AddressDAO findbyID method to find the record. It will retrieve
				 * the address record using the ID from the 'theAddressID' attribute 
				 * set on the front-end.
				 */
				myTableAddress = myAddressesDAO.findById(tempEditAddressId);
				/**
				 * Make the field editable by setting the myTableAddress editable to true
				 * and also finding this record in the current myAddresses list and setting
				 * it's editable to true.
				 */
				myAddresses.get(myAddresses.indexOf(myTableAddress)).setEditable(true);
				myTableAddress.setEditable(true);				
			}
			return "success";
		
		}catch (Exception exception){
        	myLog.log(exception.getMessage());
        	notifyMessage = exception.getMessage();
        	return "failure";
        }
	}
	
    /** Sets Address ID of record to be edited.
     *@TheCs Cohesion - Sets Address ID of record to be edited.
	 * Completeness - Completely Sets Address ID of record to be edited.
	 * Convenience - Simply Sets Address ID of record to be edited.
	 * Clarity - It is simple to understand that this Sets Address ID of record 
	 * 			 to be edited.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @param aEditAddressId Address ID of record to be edited         
	 */		
	public void setEditAddressId(Long aEditAddressId){
		/**
		 * This is set by a Property Action Listener when the edit button
		 * is clicked on the front-end.
		 */
		if (myTableAddress.getAddressid() == null && aEditAddressId != null){
			/**
			 * Make sure another record isn't being edited first and also that
			 * the variable being set to isn't null then set the address id 
			 * variable.
			 */
			tempEditAddressId = aEditAddressId;
		}
	}
	
    /** Validates email address field.
     *@TheCs Cohesion - Validates email address field.
	 * Completeness - Completely validates email address field.
	 * Convenience - Simply validates email address field.
	 * Clarity - It is simple to understand that this validates email address field.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @param context FacesContext used to add message to front-end message object
     * @param validate UIComponent the UI Component this is for
     * @param value Object the text entered into the email address field
     * @throws Exception if context is null
     * @exception Exception general exception capture         
	 */		
    public void validateEmail(FacesContext context, 
    		UIComponent validate, Object value){
    	try{
    		if(context == null || validate == null || value == null){
    			throw new Exception("One or more components are null on validateEmail");
    		}
    
    		String email = (String)value; //Email address to be checked

    		/**
    		 * This regex ensures the email entered matches RFC 2822. I won't take credit for
    		 * this one, I got this from Regexbuddy 3.
    		 */
            String extRegex = 
            	"[a-z0-9!#$%&'*+\\/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+\\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?";
            Pattern pattern = Pattern.compile(extRegex);
            Matcher matcher = pattern.matcher(email);
            if (!matcher.find()){
    			FacesMessage msg = new FacesMessage("Invalid Email entered");
    			context.addMessage(validate.getClientId(context), msg);
            }    		
    		/**
    		 * If the email address field is greater than 50 let the user know they
    		 * exceeded the maximum allowed length.
    		 */
    		if(email.length() > 50){
    			((UIInput)validate).setValid(false);
    			FacesMessage msg = new FacesMessage("Invalid Email entered");
    			context.addMessage(validate.getClientId(context), msg);
    		}
        
        }catch (Exception exception){
        	myLog.log(exception.getMessage());
        	notifyMessage = exception.getMessage();
        }        
    }
    
    /** Validates phone number field.
     *@TheCs Cohesion - Validates phone number field.
	 * Completeness - Completely validates phone number field.
	 * Convenience - Simply validates phone number field.
	 * Clarity - It is simple to understand that this validates phone number field.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @param context FacesContext used to add message to front-end message object
     * @param validate UIComponent the UI Component this is for
     * @param value Object the text entered into the phone number field
     * @throws Exception if context is null
     * @exception Exception general exception capture         
	 */	    
    public void validatePhone(FacesContext context, 
    		UIComponent validate, Object value){
    	try{
    		if(context == null || validate == null || value == null){
    			throw new Exception("One or more components are null on validatePhone");
    		}
    		
    		String phone = (String)value;//Phone number to be checked
    		
    		/**
    		 * This regex ensures the phone number entered is a valid North America
    		 *  phone number. Again this one I got from Regexbuddy 3.
    		 */
            String extRegex = 
            	"\\(?\\b[0-9]{3}\\)?[-\\. ]?[0-9]{3}[-\\. ]?[0-9]{4}\\b";
            Pattern pattern = Pattern.compile(extRegex);
            Matcher matcher = pattern.matcher(phone);
            if (!matcher.find()){
    			FacesMessage msg = new FacesMessage("Invalid Phone Number entered");
    			context.addMessage(validate.getClientId(context), msg);
            }    		
    		/**
    		 * If the length is greater than 30 then add a message to the front-end
    		 *  to let the user know they exceeded the max length.
    		 */
    		if(phone.length() > 30){
    			((UIInput)validate).setValid(false);
    			FacesMessage msg = new FacesMessage("Phone Number is incorrect");
    			context.addMessage(validate.getClientId(context), msg);
    		}
        
        }catch (Exception exception){
        	myLog.log(exception.getMessage());
        	notifyMessage = exception.getMessage();
        }        
    }
    
    /** Validates zip code field.
     *@TheCs Cohesion - Validates zip code field.
	 * Completeness - Completely validates zip code field.
	 * Convenience - Simply validates zip code field.
	 * Clarity - It is simple to understand that this validates the zip code field.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @param context FacesContext used to add message to front-end message object
     * @param validate UIComponent the UI Component this is for
     * @param value Object the text entered into the zip code field
     * @throws Exception if context is null
     * @exception Exception general exception capture         
	 */	    
    public void validateZip(FacesContext context, 
    		UIComponent validate, Object value){
    	try{
    		if(context == null || validate == null || value == null){
    			throw new Exception("One or more components are null on validateZip");
    		}
    		
    		String zip = (String)value;//Zip code to be checked
    		
    		/**
    		 * This regex ensures the zip code entered is only digits
    		 * and is 5 digits long.
    		 */
            String extRegex = 
            	"\\d{5}";
            Pattern pattern = Pattern.compile(extRegex);
            Matcher matcher = pattern.matcher(zip);
            if (!matcher.find()){
    			FacesMessage msg = new FacesMessage("Invalid Zip Code entered");
    			context.addMessage(validate.getClientId(context), msg);
            }    		
        
        }catch (Exception exception){
        	myLog.log(exception.getMessage());
        	notifyMessage = exception.getMessage();
        }        
    }    
    
    /** Validates State field.
     *@TheCs Cohesion - Validates State field.
	 * Completeness - Completely validates State field.
	 * Convenience - Simply validates State field.
	 * Clarity - It is simple to understand that this validates the state field.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @param context FacesContext used to add message to front-end message object
     * @param validate UIComponent the UI Component this is for
     * @param value Object the text entered into the state field
     * @throws Exception if context is null
     * @exception Exception general exception capture         
	 */	    
    public void validateState(FacesContext context, 
    		UIComponent validate, Object value){
    	try{
    		if(context == null || validate == null || value == null){
    			throw new Exception("One or more components are null on validateState");
    		}
    		
    		String state = (String)value;//State to be checked
    		
    		/**
    		 * This regex ensures the state entered only contains letters
    		 * and is only 2 letters long.
    		 */
            String extRegex = 
            	"\\p{L}{2}";
            Pattern pattern = Pattern.compile(extRegex);
            Matcher matcher = pattern.matcher(state);
            if (!matcher.find()){
    			FacesMessage msg = new FacesMessage("Invalid State entered");
    			context.addMessage(validate.getClientId(context), msg);
            }    		
        
        }catch (Exception exception){
        	myLog.log(exception.getMessage());
        	notifyMessage = exception.getMessage();
        }        
    }    
    
    /** Validates all other input fields.
     *@TheCs Cohesion - Validates all other input fields.
	 * Completeness - Completely validates all other input fields.
	 * Convenience - Simply validates all other input fields.
	 * Clarity - It is simple to understand that this validates all other input fields.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @param context FacesContext used to add message to front-end message object
     * @param validate UIComponent the UI Component this is for
     * @param value Object the text entered into the fields on the add form
     * @throws Exception if context is null
     * @exception Exception general exception capture         
	 */	    
    public void validateAllOthers(FacesContext context, UIComponent validate, Object value){
    	try{
    		if(context == null || validate == null || value == null){
    			throw new Exception("One or more components are null on validateAllOthers");
    		}
    
    		/**
    		 * Each of the else if statements check the clientID of the component in 
    		 * question and will check the size to make sure none of the fields are
    		 * larger than what is allowed by the database.
    		 */    		
    		String allOther = (String)value; //Value to be checked

    		if(allOther.equals("")){
    			((UIInput)validate).setValid(false);
    			FacesMessage msg = new FacesMessage("Everything with an asterisk* is required!");
    			context.addMessage(validate.getClientId(context), msg);
    		}else if(validate.getClientId(context).toLowerCase().contains("lastname") && 
			allOther.length() > 30){
    			FacesMessage msg = 
    				new FacesMessage("Last Name is incorrect");
    			context.addMessage(validate.getClientId(context), msg);    			
    		}else if(validate.getClientId(context).toLowerCase().contains("firstname") &&
				allOther.length() > 30){
    			FacesMessage msg = 
    				new FacesMessage("First Name is incorrect");
    			context.addMessage(validate.getClientId(context), msg);    			
    		}else if(validate.getClientId(context).toLowerCase().contains("street") &&
				allOther.length() > 150){
    			FacesMessage msg = 
    				new FacesMessage("Street is incorrect");
    			context.addMessage(validate.getClientId(context), msg);    			
    		}else if(validate.getClientId(context).toLowerCase().contains("city") &&
				allOther.length() > 30){
    			FacesMessage msg = 
    				new FacesMessage("City is incorrect");
    			context.addMessage(validate.getClientId(context), msg);    			
    		}
    	}catch (Exception exception){
        	myLog.log(exception.getMessage());
        	notifyMessage = exception.getMessage();
        }        
    }   
    

    
    /** Sets default order to ascending.
     *@TheCs Cohesion - Sets default order to ascending.
	 * Completeness - Completely sets default order to ascending.
	 * Convenience - Simply sets default order to ascending.
	 * Clarity - It is simple to understand that this sets default order to ascending.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @param   sortColumn to sort by ascending
     * @return  true to setup ascending
     */
    protected boolean isDefaultAscending(String sortColumn) {
        return true;
    }

    /** Sorts myAddresses, a list of addresses objects.
     *@TheCs Cohesion - Sorts myAddresses, a list of addresses objects.
	 * Completeness - Completely sorts myAddresses, a list of addresses objects.
	 * Convenience - Simply sorts myAddresses, a list of addresses objects.
	 * Clarity - It is simple to understand that this sorts myAddresses, a 
	 *           list of addresses objects.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @exception Exception general exception capture
     */    
    protected void sort() {
    	try{
    		/**
    		 * This creates a comparator object that will be used to sort the current
    		 * myAddress list of addresses.
    		 */
    		Comparator<Object> comparator = new Comparator<Object>() {
    			public int compare(Object o1, Object o2) {
    				Addresses c1 = (Addresses) o1;
    				Addresses c2 = (Addresses) o2;
    				if (sortColumnName == null) {
    					return 0;
    				}
    				/**
    				 * Basically, it first determines which field is currently selected for
    				 * sorting, then returns how to compare the addresses object depending on
    				 * whether it is being sorted ascending or not.
    				 */
    				if (sortColumnName.equals("ID")) {
    					return ascending ?
    							new Long(c1.getAddressid()).compareTo(new Long(c2.getAddressid())) :
    							new Long(c2.getAddressid()).compareTo(new Long(c1.getAddressid()));
    				} else if (sortColumnName.equals("First Name")) {
    					return ascending ? c1.getFirstname().compareToIgnoreCase(c2.getFirstname()) :
    						c2.getFirstname().compareToIgnoreCase(c1.getFirstname());
    				} else if (sortColumnName.equals("Last Name")) {
    					return ascending ? c1.getLastname().compareToIgnoreCase(c2.getLastname()) :
                            c2.getLastname().compareToIgnoreCase(c1.getLastname());
    				} else if (sortColumnName.equals("Street")) {
    					return ascending ?
                            c1.getStreet().compareToIgnoreCase(c2.getStreet()) :
                            c2.getStreet().compareToIgnoreCase(c1.getStreet());
    				} else if (sortColumnName.equals("City")) {
    					return ascending ?
                            c1.getCity().compareToIgnoreCase(c2.getCity()) :
                            c2.getCity().compareToIgnoreCase(c1.getCity());
    				}  else if (sortColumnName.equals("State")) {
    					return ascending ?
                            c1.getState().compareToIgnoreCase(c2.getState()) :
                            c2.getState().compareToIgnoreCase(c1.getState());
    				} else if (sortColumnName.equals("Zip Code")) {
    					return ascending ?
                            c1.getZip().compareToIgnoreCase(c2.getZip()) :
                            c2.getZip().compareToIgnoreCase(c1.getZip());
    				} else if (sortColumnName.equals("Email Address")) {
    					return ascending ?
                            c1.getEmailaddress().compareToIgnoreCase(c2.getEmailaddress()) :
                            c2.getEmailaddress().compareToIgnoreCase(c1.getEmailaddress());
    				} else if (sortColumnName.equals("Phone Number")) {
    					return ascending ?
                            c1.getPhonenumber().compareToIgnoreCase(c2.getPhonenumber()) :
                            c2.getPhonenumber().compareToIgnoreCase(c1.getPhonenumber());
    				} else return 0;
    				}
    			};
    			/**
    			 * Finally, after comparator is created use below to
    			 * sort myAddresses.
    			 */
    			Collections.sort(myAddresses, comparator);
        
        }catch (Exception exception){
        	myLog.log(exception.getMessage());
        	notifyMessage = exception.getMessage();
        }        
        
    }
        
    /** Opens/Closes the Instructions Popup by setting it's boolean to true/false.
     *@TheCs Cohesion - Opens/Closes the Instructions Popup by setting it's boolean to true/false.
	 * Completeness - Completely opens/closes the Instructions Popup by setting it's boolean
	 *                to true/false.
	 * Convenience - Simply opens/closes the Instructions Popup by setting it's boolean
	 *                to true/false.
	 * Clarity - It is simple to understand that this opens/closes the Instructions Popup by 
	 *           setting it's boolean to true/false.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @return success
     */     
    public String getPopup() {
        instructionsVisible = !instructionsVisible;
        return "success";
    }

    /** Returns the current boolean value for the instructions Popup.
     *@TheCs Cohesion - Returns the current boolean value for the instructions Popup.
	 * Completeness - Completely returns the current boolean value for the instructions
	 *                Popup.
	 * Convenience - Simply returns the current boolean value for the instructions Popup.
	 * Clarity - It is simple to understand that this returns the current boolean value 
	 *           for the instructions Popup.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @return instructionsVisible boolean
     */      
    public boolean getPopupVisible(){
    	return instructionsVisible;
    }
    
    /** Returns a string of instructions for using the front-end.
     *@TheCs Cohesion - Returns a string of instructions for using the front-end.
	 * Completeness - Completely returns a string of instructions for using the front-end.
	 * Convenience - Simply returns a string of instructions for using the front-end.
	 * Clarity - It is simple to understand that this returns a string of instructions 
	 *           for using the front-end.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @return a string of instructions
     */      
    public String getInstructions(){
    	return "<b>Add Address:</b> <br />" +
    	"1) Enter in all info with an asterisk next to it. <br />" +
    	"2) Click the 'Add' button. <br />" +
    	"3) Click the 'Clear button to reset all fields. <br />" +
    	"<b>Search by last name:</b> <br />" +
    	"1) Begin entering the last name you want to find, the autocomplete will show matching last names. <br />" +
    	"2) Once you find the last name or have it entered press the 'Enter' key and all records with this last name <br />" +
    	"   will appear in the table. <br />" +
    	"3) Clear the search field to show all records. <br />" + 
    	"<b>Edit/Delete Addresses:</b> <br />" +
    	"1) Either find by searching or scrolling through the table to find the record you want to edit. <br />" +
    	"2) Once found click the 'Edit' button next to the record and the fields will become editable. <br />" +
    	"3) Once you make your changes click the 'Save' button or the 'Delete button to delete the record. <br />" + 
    	"4) You can also click the 'Cancel' button to not update the record. <br />" +
    	"*Note - Only one record can be edited at a time.";
    }
    
    
    /** Returns a notification when a record is added, updated, deleted, and when records are shown.
     *@TheCs Cohesion - Returns a notification when a record is added, updated,
     * 					deleted, and when records are shown
	 * Completeness - Completely returns a notification when a record is added, updated,
	 * 				  deleted, and when records are shown
	 * Convenience - Simply returns a notification when a record is added, updated, 
	 * 		 	 	 deleted, and when records are shown
	 * Clarity - It is simple to understand that this returns a notification when a record 
	 * 			 is added, updated, deleted, and when records are shown
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @return a notification when a record is added, updated, deleted, and when records are shown
     */      
    public String getNotifyMessage(){
    	return notifyMessage;
    }    

}

















