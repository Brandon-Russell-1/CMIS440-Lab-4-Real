package AddressBook.bean;

/**
* Program Name: CMIS440 Lab 4 Address Book Web App
* @author Brandon R Russell
* @Course CMIS440
* Date: Jan 6, 2011
* IDE: MyEclipse 9.0 M1
* OS: Windows 7 64 bit
* Java: JDK 1.6.0_13, Java EE 5, JSF 1.2, JPA 2.0, IceFaces 1.8.1, GlassFish 2.1.1 & GlassFish v3 Prelude
* Tested on Firefox 3.6.13 w/ 22in, 17in, and 14in monitors w/ 1680x1050, 1440x900, and 1280x1024 resolution settings.
* Files: AddressBean.java, Logger.java, SortableList.java, Addresses.java, AddressesDAO.java,
* 		 EntityManagerHelper.java, persistence.xml, faces-config.xml, web.xml, AddressBook.jspx,
* 		 AddressBookCSS.css, index.html, ErrorPage.jspx, ErrorPageCSS.css, ErrorRedirect.jsp
*
* Program Requirements: 
*Minimum Assignment Requirements. Extend the example web application in Chapter 30 as follows:
*Add fields for Email Address and Phone Number to the Addresses Table in the AddressBook database.
*Add labels and text fields, with appropriate validators, to all presentation forms for the 
*Email Address and Phone Number fields.
*Implement a delete record functionality. The basic approach is to have the user search for a record 
*and then be given the option to delete this record.
*Implement an update record functionality. The basic approach is to have the user search for a record and 
*then be allowed to make changes and save these changes back to the database.
*Assignment Optional Implementations: 
*Incorporate trace logging into the Java code classes. These trace logs are invaluable in tracking down customer
*reported issues. When writing to your log file, ask yourself: 'What will I need to know if a customer reports 
*an issue and all I have is my trace log to analysis and resolve the issue'. To implement your trace logging, 
*create a class called Logger that takes a file name and optional path in its contructor and provides one or more 
*log methods. The default file name will be AddressBook.log and the default file path will be the current working
*directory. Possible log methods might be: 
*log(String msg) - log the given message to the provided Path/File Name. 
*log(String msg, int value) - log the given message and value to the provided Path/File Name in a format: message = value 
*
* Program Design: The basic program design is that once the program is loaded the user can enter into one form a new address
* to be entered into the database. In the next form the user has the option to do a search by last name, which utilizes 
* autocomplete, and displays the results in the datatable. Finally, the datatable/form allows the user to view and also
* edit/delete records. I went with a MVC design: the AddressBook.bean package is my Controller, the myPersistence package
* is my Model, and the WebRoot files are my View.
*
* Things you what me to know before I grade your work: Using MyEclipse, most of the persistence files in myPersistence package
* were auto-generated by the IDE; however, even still I did go through each file making specific changes I needed plus adding
* my own comments and styling throughout.
*/

/** This class manages interaction between front-end and back-end classes.
* Basically, this class is considered a Controller, almost like a buffer 
* between all dealings between the front-end website and the back-end database. 
*|----------------------------------------------------------------------------|
*|                           CRC: AddressBean                                 |
*|----------------------------------------------------------------------------|
*|Used to interact with back-end                           AddressBook.jspx   |
*|Used to interact with front-end                          EntityManagerHelper|
*|                                                         AddressesDAO       |
*|Object model for table entries                           Addresses          |
*|Used to keep log of user actions                         Logger             |
*|Extended to provide sorting for front-end table          SortableList       |
*|----------------------------------------------------------------------------|
*
* @TheCs Cohesion - All methods in this class work together on similar task.
* Completeness - Completely interacts with front-end and back-end classes.
* Convenience - There are sufficient methods and variables to complete the
*                required task.
* Clarity - The methods and variables are distinguishable and work in a
*           uniform manner to provide clarity to other programmers.
* Consistency - All names,parameters ,return values , and behaviors follow
*               the same basic rules.
*/



import java.util.*;
import javax.faces.model.SelectItem;
import javax.faces.application.Application;
import javax.faces.application.FacesMessage;
import javax.faces.application.ViewHandler;
import javax.faces.component.UIComponent;
import javax.faces.component.UIInput;
import javax.faces.component.UIViewRoot;
import javax.faces.context.FacesContext;
import javax.faces.event.ValueChangeEvent;
import myPersistence.Addresses;
import myPersistence.AddressesDAO;
import myPersistence.EntityManagerHelper;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


public class AddressBean extends SortableList{

	
	private AddressesDAO myAddressesDAO;
	private Addresses myTableAddress;
	private Addresses myNewAddress;
	private Addresses mySearchAddress;
	private List<Addresses> myAddresses = new ArrayList<Addresses>();
	private List<SelectItem> lastNames;
	private Logger myLog = new Logger();
	private boolean instructionsVisible = false;
	private String notifyMessage = "";
	private Long tempEditAddressId;
	
	
    

	
    /** Constructor initializes an AddressBean object.
     *@TheCs Cohesion - Initializes an AddressBean object.
	 * Completeness - Completely initializes an AddressBean object.
	 * Convenience - Simply initializes an AddressBean object.
	 * Clarity - It is simple to understand that this initializes an
     *           AddressBean object.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
	 * @exception Exception general exception capture               
	 */	
	public AddressBean() {
		/**
		 * First a call is made to the extended SortableList class to set the 
		 * current sorted column to the 'ID' field. The clear method is called
		 * to initialize three objects for adding, searching, and editing/deleting
		 * Addresses entities and also to fill the myAddresses list for the 
		 * front-end datatable.
		 */
		super("ID");
		try{
			myAddressesDAO = new AddressesDAO();
			myNewAddress = new Addresses();
			mySearchAddress = new Addresses();
			myTableAddress = new Addresses();
			myAddresses = myAddressesDAO.findAll();
		}catch(Exception exception){
			myLog.log(exception.getMessage());
			notifyMessage = exception.getMessage();
		}
		
	}
	    
	

    /** Retrieves the current address object used by the table.
     *@TheCs Cohesion - Retrieves the current address object used by the table.
	 * Completeness - Completely retrieves the current address object used by 
	 * 				  the table.
	 * Convenience - Simply retrieves the current address object used by the table.
	 * Clarity - It is simple to understand that this retrieves the current 
	 *           address object used by the table.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
	 * @return myTableAddress object               
	 * @throws Exception if myTableAddress is null
	 * @exception Exception general exception capture 
	 */		
	public Addresses getCurrentTableAddress(){
		try{
			if (myTableAddress == null){
				throw new Exception(
						"The Table Address object is null on getCurrentTableAddress!");
			}			
			return myTableAddress;
		}catch (Exception exception){
			myLog.log(exception.getMessage());
			notifyMessage = exception.getMessage();
			return null;
		}					
		
	}

    /** Sets the current address object used by the table.
     *@TheCs Cohesion - Sets the current address object used by the table.
	 * Completeness - Completely sets the current address object used by 
	 * 				  the table.
	 * Convenience - Simply sets the current address object used by the table.
	 * Clarity - It is simple to understand that this sets the current 
	 *           address object used by the table.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
	 * @param tableAddress sets the table address object to another address object
	 * @throws Exception if tableAddress is null
	 * @exception Exception general exception capture               
	 */			
	public void setCurrentTableAddress(Addresses tableAddress){
		try{
			if (tableAddress == null){
				throw new Exception(
						"The Table Address object is null on setCurrentTableAddress!");
			}			
			myTableAddress = tableAddress;
		}catch (Exception exception){
			myLog.log(exception.getMessage());
			notifyMessage = exception.getMessage();
		}		
	}
		
    /** Retrieves the current address object used to add a record.
     *@TheCs Cohesion - Retrieves the current address object used to add a record.
	 * Completeness - Completely retrieves the current address object used to 
	 *                add a record.
	 * Convenience - Simply retrieves the current address object used to add a 
	 *               record.
	 * Clarity - It is simple to understand that this retrieves the current 
	 *           address object to add a record.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
	 * @return myNewAddress object  
	 * @throws Exception if myNewAddress is null
	 * @exception Exception general exception capture             
	 */			
	public Addresses getCurrentNewAddress(){
		try{
			if (myNewAddress == null){
				throw new Exception(
						"The New Address object is null on getCurrentNewAddress!");
			}
			return myNewAddress;
		}catch (Exception exception){
			myLog.log(exception.getMessage());
			notifyMessage = exception.getMessage();
			return null;
		}
	}

    /** Sets the current address object used to add a record.
     *@TheCs Cohesion - Sets the current address object used to add a record.
	 * Completeness - Completely sets the current address object used to add
	 *                a record.
	 * Convenience - Simply sets the current address object used to add a record.
	 * Clarity - It is simple to understand that this sets the current 
	 *           address object used to add a record.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
	 * @param newAddress sets the new address object to another address object     
	 * @throws Exception if newAddress is null
	 * @exception Exception general exception capture           
	 */	
	public void setCurrentNewAddress(Addresses newAddress){
		try{
			if (newAddress == null){
				throw new Exception(
						"The New Address object is null on setCurrentNewAddress!");
			}				
			myNewAddress = newAddress;
		}catch (Exception exception){
			myLog.log(exception.getMessage());
			notifyMessage = exception.getMessage();
		}		
	}	

    /** Retrieves the current address object used to search for a record.
     *@TheCs Cohesion - Retrieves the current address object used to 
     *                  search for a record.
	 * Completeness - Completely retrieves the current address object used to 
	 *                search for a record.
	 * Convenience - Simply retrieves the current address object used to search
	 *               for a record.
	 * Clarity - It is simple to understand that this retrieves the current 
	 *           address object to search for a record.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
	 * @return mySearchAddress object 
	 * @throws Exception if mySearchAddress is null
	 * @exception Exception general exception capture               
	 */		
	public Addresses getCurrentSearchAddress(){
		try{
			if (mySearchAddress == null){
				throw new Exception(
						"The Search Address object is null on getCurrentSearchAddress!");
			}			
			return mySearchAddress;
		}catch (Exception exception){
			myLog.log(exception.getMessage());
			notifyMessage = exception.getMessage();
			return null;
		}			
	}
	
    /** Sets the current address object used to search for a record.
     *@TheCs Cohesion - Sets the current address object used to search for a 
     *                  record.
	 * Completeness - Completely sets the current address object used to search
	 *                for a record.
	 * Convenience - Simply sets the current address object used to search for
	 *               a record.
	 * Clarity - It is simple to understand that this sets the current 
	 *           address object used to search for a record.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
	 * @param searchAddress sets the search address object to another address object    
	 * @throws Exception if searchAddress is null
	 * @exception Exception general exception capture           
	 */		
	public void setCurrentSearchAddress(Addresses searchAddress){
		try{
			if (searchAddress == null){
				throw new Exception(
						"The Search Address object is null on setCurrentSearchAddress!");
			}					
			mySearchAddress = searchAddress;
		}catch (Exception exception){
			myLog.log(exception.getMessage());
			notifyMessage = exception.getMessage();
		}					
	}	

    /** Sets the current list of addresses to another list of addresses.
     *@TheCs Cohesion - Sets the current list of addresses to another list
     *                  of addresses.
	 * Completeness - Completely sets the current list of addresses to another 
	 *                list of addresses.
	 * Convenience - Simply sets the current list of addresses to another list
	 *               of addresses.
	 * Clarity - It is simple to understand that this sets the current list of
	 *           addresses to another list of addresses.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
	 * @param addressesDAO set the addresses list to another addresses list   
	 * @throws Exception if addressesDAO is null
	 * @exception Exception general exception capture            
	 */			
    public void setAddressDao(AddressesDAO addressesDAO) {
    	try{
			if (addressesDAO == null){
				throw new Exception(
						"The AddressesDAO object is null on setAddressDao!");
			}    		
    		myAddressesDAO = addressesDAO;
		}catch (Exception exception){
			myLog.log(exception.getMessage());
			notifyMessage = exception.getMessage();
		}	    		
    }
	 
	
    /** Adds a new address record to the database.
     *@TheCs Cohesion - Adds a new address record to the database.
	 * Completeness - Completely adds a new address record to the database.
	 * Convenience - Simply adds a new address record to the database.
	 * Clarity - It is simple to understand that this adds a new address record
	 *           to the database.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
	 * @throws Exception if myNewAddress object is null               
	 * @exception Exception general exception capture      
	 * @return success or failure depending on if transaction goes through        
	 */			    
	public String addAddress(){
		try{
			FacesContext context = FacesContext.getCurrentInstance();
			if (myNewAddress == null){
				throw new Exception("New Address object is null on addAddress");
			}else if (context.getMessages().hasNext()){
				/**
				 * Here, if any of the fields are left blank then it creates a 
				 * new message to be displayed on the web site and returns instead
				 * of attempting to add a record since all of the fields are 
				 * required.
				 */
				FacesMessage msg = 
					new FacesMessage("Clear all errors before adding record!");
				context.addMessage("addForm:Add", msg);
				return "failure";
			}
			/**
			 * First the EntityManagerHelper is called to initiate the transaction.
			 * Then, the AddressesDAO object save method is called to persist the
			 * new address object to the database and the EntityManagerHelper
			 * is called again to commit the changes.
			 */
			EntityManagerHelper.beginTransaction();
			myAddressesDAO.save(myNewAddress);
			EntityManagerHelper.commit();
			/**
			 * myLog is called to write to a file that the add was successful and
			 * then the clear method is called to clear out all the objects and
			 * renew the list.
			 */
			myLog.log("ID: " + myNewAddress.getAddressid() 
					+ " Successfully added into database");			
			clear();
			notifyMessage = "Record Added!";
			return "success";
			}catch (Exception exception){
				myLog.log(exception.getMessage());
				notifyMessage = exception.getMessage();
				return "failure";
			}
	}

    /** Updates a address record in the database.
     *@TheCs Cohesion - Updates a address record in the database.
	 * Completeness - Completely updates a address record in the database.
	 * Convenience - Simply updates a address record in the database.
	 * Clarity - It is simple to understand that this updates a address record
	 *           in the database.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
	 * @throws Exception if myTableAddress object is null         
	 * @exception Exception general exception capture              
	 * @return success or failure depending on if transaction goes through
	 */		
	public String updateAddress(){
		try{
			FacesContext context = FacesContext.getCurrentInstance();
			if (myTableAddress == null){
				throw new Exception("MyTableAddress object is null on updateAddress");
			}else if (context.getMessages().hasNext()){
				
				/**
				 * Here, if any of the fields are left blank then it creates a 
				 * new message to be displayed on the web site and returns instead
				 * of attempting to update a record since all of the fields are 
				 * required.
				 */				
				
				 FacesMessage msg = 
					 new FacesMessage("Clear all errors before saving record!");
				 context.addMessage("editForm:Save", msg);	
				 
				return "failure";
			}				
					
			/**
			 * First the EntityManagerHelper is called to initiate the transaction.
			 * Then, the AddressesDAO object update method is called to merge the
			 * changed address object to the database and the EntityManagerHelper
			 * is called again to commit the changes.
			 */			
			EntityManagerHelper.beginTransaction();
			myAddressesDAO.update(myTableAddress);
			EntityManagerHelper.commit();
			/**
			 * myLog is called to write to a file that the update was successful and
			 * then the cancelEdit method is called to clear out all table
			 * address objects and also sets the editable property to false to
			 * indicate that the table should not have any editable fields.
			 */			
			myLog.log("ID: " + myTableAddress.getAddressid() 
					+ " Successfully updated in database");
			notifyMessage = "Record Updated!";
			cancelEdit();
			return "success";
		}catch (Exception exception){
			myLog.log(exception.getMessage());
			notifyMessage = exception.getMessage();
			return "failure";
		}		
	}
	
    /** Deletes a address record from the database.
     *@TheCs Cohesion - Deletes a address record from the database.
	 * Completeness - Completely deletes a address record from the database.
	 * Convenience - Simply deletes a address record from the database.
	 * Clarity - It is simple to understand that this deletes a address record
	 *           from the database.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.   
	 * @throws Exception if myTableAddress is null           
	 * @exception Exception general exception capture              
	 * @return success or failure depending on if transaction goes through
	 */		
	public String deleteAddress(){
		try{
			
			if (myTableAddress == null){
				throw new Exception("MyTableAddress object is null on deleteAddress");
			}else if (myTableAddress.getAddressid().toString().length() == 0){
				
				/**
				 * Here, if the addressid field is blank then it creates a 
				 * new message to be displayed on the web site and returns instead
				 * of attempting to delete a record since this is required to  
				 * delete the record.
				 */				
				
				 FacesContext context = FacesContext.getCurrentInstance();
				 FacesMessage msg = 
					 new FacesMessage("The record appears to not be selected for deletion.");
				 context.addMessage("editForm:Delete", msg);				
				return "failure";
			}			
			
			/**
			 * First the EntityManagerHelper is called to initiate the transaction.
			 * Then, the AddressesDAO object delete method is called to remove the
			 * address object from the database and the EntityManagerHelper
			 * is called again to commit the changes.
			 */				
			EntityManagerHelper.beginTransaction();
			myAddressesDAO.delete(myTableAddress);
			EntityManagerHelper.commit();
			/**
			 * myLog is called to write to a file that the delete was successful and
			 * then the cancelEdit method is called to clear out all table
			 * address objects and also sets the editable property to false to
			 * indicate that the table should not have any editable fields.
			 */				
			myLog.log("ID: " + myTableAddress.getAddressid() 
					+ " Successfully deleted from database");
			clear();
			notifyMessage = "Record Deleted!";
			return "success";
		}catch (Exception exception){
			myLog.log(exception.getMessage());
			notifyMessage = exception.getMessage();
			return "failure";
		}		
	}		
	
	
    /** Returns list of addresses objects for front-end table.
     *@TheCs Cohesion - Returns list of addresses objects for front-end table.
	 * Completeness - Completely returns list of addresses objects for front-end table.
	 * Convenience - Simply returns list of addresses objects for front-end table.
	 * Clarity - It is simple to understand that this returns list of addresses 
	 *           objects for front-end table.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
	 * @return myAddresses List 
	 * @throws Exception if mySearchAddress of myAddressesDAO are null                             
	 * @exception Exception general exception capture              
	 */		
	public List<Addresses> getAllAddresses(){

		try{
			if(mySearchAddress == null || myAddressesDAO == null){
				throw new Exception(
						"One or more objects required by the getAllAddresses are set to null!");
			}
			/**
			 * First, if mySearchAddress object doesn't have a first name set then do
			 * nothing to myAddresses List since it will already have in it at this point
			 * a current copy of all of the addresses objects. Else use the .findByLastname
			 * method of the AddressesDAO object to populate the list with all records that
			 * match the last name entered.
			 */
			if ( mySearchAddress.getLastname() == null ||
					mySearchAddress.getLastname().equals("")){
				
			}else{
				myAddresses =  
					myAddressesDAO.findByLastname(mySearchAddress.getLastname());
			}
			/**
			 * If the user has changed the column to sort on or if they have changed the
			 * direction of the sorting then call the sort method to sort the addresses
			 * before returning them.
			 */
			if (!oldSort.equals(sortColumnName) ||
					oldAscending != ascending){
					sort();
					oldSort = sortColumnName;
					oldAscending = ascending;
			}
			return myAddresses;
        }catch (Exception exception){
        	myLog.log(exception.getMessage());
        	notifyMessage = exception.getMessage();
        	return myAddresses;
        }
        
	}
	
    /** Provides auto-complete from database for search field.
     *@TheCs Cohesion - Provides auto-complete from database for search field.
	 * Completeness - Completely provides auto-complete from database for search field.
	 * Convenience - Simply provides auto-complete from database for search field.
	 * Clarity - It is simple to understand that this provides auto-complete from 
	 *           database for search field.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
	 * @param event a ValueChangeEvent linked to the search field on the front-end 
	 * @throws Exception if myAddressesDAO is null                                       
	 * @exception Exception general exception capture              
	 */		
	public void getAddressesByLastName(ValueChangeEvent event){
		/**
		 * Whenever the user types something into the search field on the
		 * front-end this method is called.
		 */
		try{
			if (myAddressesDAO == null){
				throw new Exception(
						"The myAddressesDAO object is null on getAddressesByLastName!");
			}
			/**
			 * This will take what the user typed into the searchWord object and also
			 * refresh the myAddresses list to ensure a complete list is being used.
			 */
			lastNames = new ArrayList<SelectItem>();
			myAddresses = myAddressesDAO.findAll();
			HashSet<Addresses> myTempHashSet = new HashSet<Addresses>(myAddresses);
			List<Addresses> myTempAddresses = new ArrayList<Addresses>();
			myTempAddresses.addAll(myTempHashSet);
			Object searchWord = event.getNewValue();
			for(int i = 0; i < myTempAddresses.size(); i++){
				/**
				 * If for some reason the last name for this addresses object is
				 * blank then do nothing with it. Else if the length of the addresses
				 *  last name is less than what the user has typed do nothing since this
				 *  won't be useful. Finally, take a substring of the addresses last name
				 *  so that it equals the length of the search word starting from its 
				 *  first character to determine if the two are equal. If so, and if the
				 *  lastNames list doesn't already contain this last name then add it to
				 *  the list.
				 */
				if (myTempAddresses.get(i).getLastname().length() == 0){
					
				}else if (myTempAddresses.get(i).getLastname().length() < 
						searchWord.toString().length()){
				
				}else if(myTempAddresses.get(i).getLastname()
						.substring(0,searchWord.toString().length())
						.equalsIgnoreCase(searchWord.toString())){
					
					lastNames.add(
							new SelectItem(myTempAddresses.get(i).getLastname(),
										   myTempAddresses.get(i).getLastname()));
				}
			}		
        }catch (Exception exception){
        	myLog.log(exception.getMessage());
        	notifyMessage = exception.getMessage();
        }		
		
	}
	
    /** Returns a list of last names for search field autocomplete.
     *@TheCs Cohesion - Returns a list of last names for search field autocomplete.
	 * Completeness - Completely Returns a list of last names for search field autocomplete.
	 * Convenience - Simply Returns a list of last names for search field autocomplete.
	 * Clarity - It is simple to understand that this Returns a list of last names 
	 *           for search field autocomplete.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @return lastNames a list of last names that match search field.   
     * @exception Exception general exception capture      
	 */		
	public List<SelectItem> getLastNameMatches(){
		try{
			return lastNames;
        }catch (Exception exception){
        	myLog.log(exception.getMessage());
        	notifyMessage = exception.getMessage();
        	return null;
        }			
	}
	
    /** Renews Addresses objects, refills myAddresses list, and undo's edit on table.
     *@TheCs Cohesion - Renews Addresses objects, refills myAddresses list, and undo's 
     *                  edit on table.
	 * Completeness - Completely renews Addresses objects, refills myAddresses list, 
	 *                and undo's edit on table.
	 * Convenience - Simply Renews Addresses objects, refills myAddresses list, and
	 *               undo's edit on table.
	 * Clarity - It is simple to understand that this Renews Addresses objects, 
	 *           refills myAddresses list, and undo's edit on table.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.  
     * @throws Exception if myAddressesDAO is null
     * @exception Exception general exception capture
     * @return success or failure depending on if clear is handled properly
	 */		
	public String clear(){
		try{
			if(myAddressesDAO == null){
				throw new Exception("myAddressesDAO is null on clear");
			}
			myNewAddress = new Addresses();
			mySearchAddress = new Addresses();
			myAddresses = myAddressesDAO.findAll();
			notifyMessage = "";
			cancelEdit();
			/**
			 * The code below gets the current FacesContext and forces 
			 * the page to rerender, making sure a good 'Clear' is made.
			 */
			FacesContext context = FacesContext.getCurrentInstance();
			Application application = context.getApplication();
			ViewHandler viewHandler = application.getViewHandler();
			UIViewRoot viewRoot = viewHandler.createView(context, context
					.getViewRoot().getViewId());
			context.setViewRoot(viewRoot);
			context.renderResponse(); //Optional
			return "success";
        }catch (Exception exception){
        	myLog.log(exception.getMessage());
        	notifyMessage = exception.getMessage();
        	return "failure";
        }		    
		
	}
	
    /** Disables editable field on front-end table.
     *@TheCs Cohesion - Disables editable field on front-end table.
	 * Completeness - Completely disables editable field on front-end table.
	 * Convenience - Simply disables editable field on front-end table.
	 * Clarity - It is simple to understand that this disables editable field 
	 *           on front-end table.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @return success       
	 */		
	public String cancelEdit(){
		if(myTableAddress != null){
			/**
			 * If not null then set the editable to false to clean up
			 * the UI.
			 */
			myTableAddress.setEditable(false);
		}
		myTableAddress = new Addresses();
		return "success";
	}
	
    /** Makes a record on the front-end table editable.
     *@TheCs Cohesion - Makes a record on the front-end table editable.
	 * Completeness - Completely makes a record on the front-end table editable.
	 * Convenience - Simply makes a record on the front-end table editable.
	 * Clarity - It is simple to understand that this makes a record on 
	 *           the front-end table editable.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @throws Exception if myAddressesDAO is null
     * @exception Exception general exception capture         
     * @return success or failure depending on if transaction goes through
	 */		
	public String editAction() {
		try{
			if(myAddressesDAO == null){
				throw new Exception("myAddressesDAO is null on editAction!");
			}
			/**
			 * If another record is already being edited then return here and do nothing.
			 */
			if (myTableAddress.getAddressid()!= null){
				return "failure";
			}		
			/**
			 * Set the myTableAddress object to the record that was clicked to be edited
			 * by using the AddressDAO findbyID method to find the record. It will retrieve
			 * the actually ID from the 'theAddressID' attribute set on the front-end.
			 */			
			myTableAddress = myAddressesDAO.findById(tempEditAddressId);
			tempEditAddressId = null;
			/**
			 * Make the field editable.
			 */
			myTableAddress.setEditable(true);
			return "success";
		
		}catch (Exception exception){
        	myLog.log(exception.getMessage());
        	notifyMessage = exception.getMessage();
        	return "failure";
        }
	}
	
    /** Sets Address ID of record to be edited.
     *@TheCs Cohesion - Sets Address ID of record to be edited.
	 * Completeness - Completely Sets Address ID of record to be edited.
	 * Convenience - Simply Sets Address ID of record to be edited.
	 * Clarity - It is simple to understand that this Sets Address ID of record 
	 * 			 to be edited.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @param aEditAddressId Address ID of record to be edited         
	 */		
	public void setEditAddressId(Long aEditAddressId){
		tempEditAddressId = aEditAddressId;
	}
	
    /** Validates email address field.
     *@TheCs Cohesion - Validates email address field.
	 * Completeness - Completely validates email address field.
	 * Convenience - Simply validates email address field.
	 * Clarity - It is simple to understand that this validates email address field.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @param context FacesContext used to add message to front-end message object
     * @param validate UIComponent the UI Component this is for
     * @param value Object the text entered into the email address field
     * @throws Exception if context is null
     * @exception Exception general exception capture         
	 */		
    public void validateEmail(FacesContext context, 
    		UIComponent validate, Object value){
    	try{
    		if(context == null){
    			throw new Exception("FacesContext null on validateEmail");
    		}
    
    		String email = (String)value;

    		/**
    		 * This regex ensures the email entered matches RFC 2822. I won't take credit for
    		 * this one, I got this from Regexbuddy 3.
    		 */
            String extRegex = 
            	"[a-z0-9!#$%&'*+\\/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+\\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?";
            Pattern pattern = Pattern.compile(extRegex);
            Matcher matcher = pattern.matcher(email);
            if (!matcher.find()){
    			FacesMessage msg = new FacesMessage("Invalid Email entered");
    			context.addMessage(validate.getClientId(context), msg);
            }    		
    		/**
    		 * If the email address field is greater than 50 let the user know they
    		 * exceeded the maximum allowed length.
    		 */
    		if(email.length() > 50){
    			((UIInput)validate).setValid(false);
    			FacesMessage msg = new FacesMessage("Invalid Email entered");
    			context.addMessage(validate.getClientId(context), msg);
    		}
        
        }catch (Exception exception){
        	myLog.log(exception.getMessage());
        	notifyMessage = exception.getMessage();
        }        
    }
    
    /** Validates phone number field.
     *@TheCs Cohesion - Validates phone number field.
	 * Completeness - Completely validates phone number field.
	 * Convenience - Simply validates phone number field.
	 * Clarity - It is simple to understand that this validates phone number field.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @param context FacesContext used to add message to front-end message object
     * @param validate UIComponent the UI Component this is for
     * @param value Object the text entered into the phone number field
     * @throws Exception if context is null
     * @exception Exception general exception capture         
	 */	    
    public void validatePhone(FacesContext context, 
    		UIComponent validate, Object value){
    	try{
    		if(context == null){
    			throw new Exception("FacesContext null on validatePhone");
    		}
    		
    		String phone = (String)value;
    		
    		/**
    		 * This regex ensures the phone number entered is a valid North America
    		 *  phone number. Again this one I got from Regexbuddy 3.
    		 */
            String extRegex = 
            	"\\(?\\b[0-9]{3}\\)?[-\\. ]?[0-9]{3}[-\\. ]?[0-9]{4}\\b";
            Pattern pattern = Pattern.compile(extRegex);
            Matcher matcher = pattern.matcher(phone);
            if (!matcher.find()){
    			FacesMessage msg = new FacesMessage("Invalid Phone Number entered");
    			context.addMessage(validate.getClientId(context), msg);
            }    		
    		/**
    		 * If the length is greater than 30 then add a message to the front-end
    		 *  to let the user know they exceeded the max length.
    		 */
    		if(phone.length() > 30){
    			((UIInput)validate).setValid(false);
    			FacesMessage msg = new FacesMessage("Phone Number is incorrect");
    			context.addMessage(validate.getClientId(context), msg);
    		}
        
        }catch (Exception exception){
        	myLog.log(exception.getMessage());
        	notifyMessage = exception.getMessage();
        }        
    }
    
    /** Validates zip code field.
     *@TheCs Cohesion - Validates zip code field.
	 * Completeness - Completely validates zip code field.
	 * Convenience - Simply validates zip code field.
	 * Clarity - It is simple to understand that this validates the zip code field.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @param context FacesContext used to add message to front-end message object
     * @param validate UIComponent the UI Component this is for
     * @param value Object the text entered into the zip code field
     * @throws Exception if context is null
     * @exception Exception general exception capture         
	 */	    
    public void validateZip(FacesContext context, 
    		UIComponent validate, Object value){
    	try{
    		if(context == null){
    			throw new Exception("FacesContext null on validateZip");
    		}
    		
    		String zip = (String)value;
    		
    		/**
    		 * This regex ensures the zip code entered is only digits
    		 * and is 5 digits long.
    		 */
            String extRegex = 
            	"\\d{5}";
            Pattern pattern = Pattern.compile(extRegex);
            Matcher matcher = pattern.matcher(zip);
            if (!matcher.find()){
    			FacesMessage msg = new FacesMessage("Invalid Zip Code entered");
    			context.addMessage(validate.getClientId(context), msg);
            }    		
        
        }catch (Exception exception){
        	myLog.log(exception.getMessage());
        	notifyMessage = exception.getMessage();
        }        
    }    
    
    /** Validates State field.
     *@TheCs Cohesion - Validates State field.
	 * Completeness - Completely validates State field.
	 * Convenience - Simply validates State field.
	 * Clarity - It is simple to understand that this validates the state field.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @param context FacesContext used to add message to front-end message object
     * @param validate UIComponent the UI Component this is for
     * @param value Object the text entered into the state field
     * @throws Exception if context is null
     * @exception Exception general exception capture         
	 */	    
    public void validateState(FacesContext context, 
    		UIComponent validate, Object value){
    	try{
    		if(context == null){
    			throw new Exception("FacesContext null on validateState");
    		}
    		
    		String state = (String)value;
    		
    		/**
    		 * This regex ensures the state entered only contains letters
    		 * and is only 2 letters long.
    		 */
            String extRegex = 
            	"\\p{L}{2}";
            Pattern pattern = Pattern.compile(extRegex);
            Matcher matcher = pattern.matcher(state);
            if (!matcher.find()){
    			FacesMessage msg = new FacesMessage("Invalid State entered");
    			context.addMessage(validate.getClientId(context), msg);
            }    		
        
        }catch (Exception exception){
        	myLog.log(exception.getMessage());
        	notifyMessage = exception.getMessage();
        }        
    }    
    
    /** Validates all other input fields.
     *@TheCs Cohesion - Validates all other input fields.
	 * Completeness - Completely validates all other input fields.
	 * Convenience - Simply validates all other input fields.
	 * Clarity - It is simple to understand that this validates all other input fields.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @param context FacesContext used to add message to front-end message object
     * @param validate UIComponent the UI Component this is for
     * @param value Object the text entered into the fields on the add form
     * @throws Exception if context is null
     * @exception Exception general exception capture         
	 */	    
    public void validateAllOthers(FacesContext context, UIComponent validate, Object value){
    	try{
    		if(context == null){
    			throw new Exception("FacesContext null on validateEmail");
    		}    		
    
    		/**
    		 * Each of the else if statements check the clientID of the component in 
    		 * question and will check the size to make sure none of the fields are
    		 * larger than what is allowed by the database.
    		 */    		
    		String allOther = (String)value;

    		if(allOther.equals("")){
    			((UIInput)validate).setValid(false);
    			FacesMessage msg = new FacesMessage("Everything with an asterisk* is required!");
    			context.addMessage(validate.getClientId(context), msg);
    		}else if(validate.getClientId(context).toLowerCase().contains("lastname") && 
			allOther.length() > 30){
    			FacesMessage msg = 
    				new FacesMessage("Last Name is incorrect");
    			context.addMessage(validate.getClientId(context), msg);    			
    		}else if(validate.getClientId(context).toLowerCase().contains("firstname") &&
				allOther.length() > 30){
    			FacesMessage msg = 
    				new FacesMessage("First Name is incorrect");
    			context.addMessage(validate.getClientId(context), msg);    			
    		}else if(validate.getClientId(context).toLowerCase().contains("street") &&
				allOther.length() > 150){
    			FacesMessage msg = 
    				new FacesMessage("Street is incorrect");
    			context.addMessage(validate.getClientId(context), msg);    			
    		}else if(validate.getClientId(context).toLowerCase().contains("city") &&
				allOther.length() > 30){
    			FacesMessage msg = 
    				new FacesMessage("City is incorrect");
    			context.addMessage(validate.getClientId(context), msg);    			
    		}
    	}catch (Exception exception){
        	myLog.log(exception.getMessage());
        	notifyMessage = exception.getMessage();
        }        
    }   
    

    
    /** Sets default order to ascending.
     *@TheCs Cohesion - Sets default order to ascending.
	 * Completeness - Completely sets default order to ascending.
	 * Convenience - Simply sets default order to ascending.
	 * Clarity - It is simple to understand that this sets default order to ascending.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @param   sortColumn to sort by ascending
     * @return  true to setup ascending
     */
    protected boolean isDefaultAscending(String sortColumn) {
        return true;
    }

    /** Sorts myAddresses, a list of addresses objects.
     *@TheCs Cohesion - Sorts myAddresses, a list of addresses objects.
	 * Completeness - Completely sorts myAddresses, a list of addresses objects.
	 * Convenience - Simply sorts myAddresses, a list of addresses objects.
	 * Clarity - It is simple to understand that this sorts myAddresses, a 
	 *           list of addresses objects.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @exception Exception general exception capture
     */    
    protected void sort() {
    	try{
    		/**
    		 * This creates a comparator object that will be used to sort the current
    		 * myAddress list of addresses.
    		 */
    		Comparator<Object> comparator = new Comparator<Object>() {
    			public int compare(Object o1, Object o2) {
    				Addresses c1 = (Addresses) o1;
    				Addresses c2 = (Addresses) o2;
    				if (sortColumnName == null) {
    					return 0;
    				}
    				/**
    				 * Basically, it first determines which field is currently selected for
    				 * sorting, then returns how to compare the addresses object depending on
    				 * whether it is being sorted ascending or not.
    				 */
    				if (sortColumnName.equals("ID")) {
    					return ascending ?
    							new Long(c1.getAddressid()).compareTo(new Long(c2.getAddressid())) :
    							new Long(c2.getAddressid()).compareTo(new Long(c1.getAddressid()));
    				} else if (sortColumnName.equals("First Name")) {
    					return ascending ? c1.getFirstname().compareTo(c2.getFirstname()) :
    						c2.getFirstname().compareTo(c1.getFirstname());
    				} else if (sortColumnName.equals("Last Name")) {
    					return ascending ? c1.getLastname().compareTo(c2.getLastname()) :
                            c2.getLastname().compareTo(c1.getLastname());
    				} else if (sortColumnName.equals("Street")) {
    					return ascending ?
                            c1.getStreet().compareTo(c2.getStreet()) :
                            c2.getStreet().compareTo(c1.getStreet());
    				} else if (sortColumnName.equals("City")) {
    					return ascending ?
                            c1.getCity().compareTo(c2.getCity()) :
                            c2.getCity().compareTo(c1.getCity());
    				}  else if (sortColumnName.equals("State")) {
    					return ascending ?
                            c1.getState().compareTo(c2.getState()) :
                            c2.getState().compareTo(c1.getState());
    				} else if (sortColumnName.equals("Zip Code")) {
    					return ascending ?
                            c1.getZip().compareTo(c2.getZip()) :
                            c2.getZip().compareTo(c1.getZip());
    				} else if (sortColumnName.equals("Email Address")) {
    					return ascending ?
                            c1.getEmailaddress().compareTo(c2.getEmailaddress()) :
                            c2.getEmailaddress().compareTo(c1.getEmailaddress());
    				} else if (sortColumnName.equals("Phone Number")) {
    					return ascending ?
                            c1.getPhonenumber().compareTo(c2.getPhonenumber()) :
                            c2.getPhonenumber().compareTo(c1.getPhonenumber());
    				} else return 0;
    				}
    			};
    			Collections.sort(myAddresses, comparator);
        
        }catch (Exception exception){
        	myLog.log(exception.getMessage());
        	notifyMessage = exception.getMessage();
        }        
        
    }
        
    /** Opens/Closes the Instructions Popup by setting it's boolean to true.
     *@TheCs Cohesion - Opens/Closes the Instructions Popup by setting it's boolean to true.
	 * Completeness - Completely opens/closes the Instructions Popup by setting it's boolean
	 *                to true.
	 * Convenience - Simply opens/closes the Instructions Popup by setting it's boolean
	 *                to true.
	 * Clarity - It is simple to understand that this opens/closes the Instructions Popup by 
	 *           setting it's boolean to true.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @return success
     */     
    public String getPopup() {
        instructionsVisible = !instructionsVisible;
        return "success";
    }

    /** Returns the current boolean value for the instructions Popup.
     *@TheCs Cohesion - Returns the current boolean value for the instructions Popup.
	 * Completeness - Completely returns the current boolean value for the instructions
	 *                Popup.
	 * Convenience - Simply returns the current boolean value for the instructions Popup.
	 * Clarity - It is simple to understand that this returns the current boolean value 
	 *           for the instructions Popup.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @return instructionsVisible boolean
     */      
    public boolean getPopupVisible(){
    	return instructionsVisible;
    }
    
    /** Returns a string of instructions for using the front-end.
     *@TheCs Cohesion - Returns a string of instructions for using the front-end.
	 * Completeness - Completely returns a string of instructions for using the front-end.
	 * Convenience - Simply returns a string of instructions for using the front-end.
	 * Clarity - It is simple to understand that this returns a string of instructions 
	 *           for using the front-end.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @return a string of instructions
     */      
    public String getInstructions(){
    	return "<b>Add Address:</b> <br />" +
    	"1) Enter in all info with an asterisk next to it. <br />" +
    	"2) Click the 'Add' button. <br />" +
    	"3) Click the 'Clear button to reset all fields. <br />" +
    	"<b>Search by last name:</b> <br />" +
    	"1) Begin entering the last name you want to find, the autocomplete will show matching last names. <br />" +
    	"2) Once you find the last name or have it entered press the 'Enter' key and all records with this last name <br />" +
    	"   will appear in the table. <br />" +
    	"3) Clear the search field to show all records. <br />" + 
    	"<b>Edit/Delete Addresses:</b> <br />" +
    	"1) Either find by searching or scrolling through the table to find the record you want to edit. <br />" +
    	"2) Once found click the 'Edit' button next to the record and the fields will become editable. <br />" +
    	"3) Once you make your changes click the 'Save' button or the 'Delete button to delete the record. <br />" + 
    	"4) You can also click the 'Cancel' button to not update the record. <br />" +
    	"*Note - Only one record can be edited at a time. <br />" +
    	"*Note - The 'Clear' button clear all fields, not just the 'Add Address' fields.";
    }
    
    
    /** Returns a notification when a record is added, updated, or deleted.
     *@TheCs Cohesion - Returns a notification when a record is added, updated, or deleted.
	 * Completeness - Completely a notification when a record is added, updated, or deleted.
	 * Convenience - Simply a notification when a record is added, updated, or deleted.
	 * Clarity - It is simple to understand that this returns a notification when a record 
	 * 			 is added, updated, or deleted.
	 * Consistency - It uses the same syntax rules as the rest of the class and
	 *               continues to use proper casing and indentation.
     * @return a notification when a record is added, updated, or deleted
     */      
    public String getNotifyMessage(){
    	return notifyMessage;
    }    

}

















